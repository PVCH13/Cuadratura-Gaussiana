{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>El c\u00e1lculo de integrales definidas es fundamental en la matem\u00e1tica aplicada, con aplicaciones  que abarcan desde la f\u00edsica y la ingenier\u00eda, hasta la econom\u00eda y las ciencias computacionales.  En muchos casos, la integral de una funci\u00f3n puede calcularse de forma exacta usando m\u00e9todos  anal\u00edticos, pero no siempre es as\u00ed, puesto que pueden existir funciones muy complejas, expresiones que no  poseen una primitiva elemental o integrales definidas que a pesar de tener soluci\u00f3n exacta  resultan costosas de evaluar.</p> <p>Dado lo anterior, nace la necesidad de emplear m\u00e9todos num\u00e9ricos. Estos m\u00e9todos  permiten obtener una aproximaci\u00f3n eficiente y controlada del valor de una integral.  Existen diversas alternativas para aplicar estos m\u00e9todos, como lo es el m\u00e9todo del trapecio, la regla de Simpson o la cuadratura Gaussiana. En este caso espec\u00edfico se aborda la \u00faltima, la cual destaca por su precisi\u00f3n, logrando resultados muy  cercanos al valor exacto de la integral utilizando un n\u00famero relativamente peque\u00f1o de puntos  de evaluaci\u00f3n.</p>"},{"location":"explanation/","title":"M\u00e9todo de Cuadratura Gaussiana","text":"<p>La integraci\u00f3n num\u00e9rica busca aproximar integrales definidas cuando no es posible  obtener una soluci\u00f3n anal\u00edtica exacta o cuando evaluarla resulta demasiado costoso.  El m\u00e9todo de cuadratura Gaussiana, en particular la cuadratura de Gauss\u2013Legendre,  es una de las t\u00e9cnicas m\u00e1s eficientes dentro de este campo.</p> <p>Si queremos aproximar una integral definida de la forma:</p> \\[\\begin{align} I = \\int_a^b f(x)\\,dx \\end{align}\\] <p>La idea de los m\u00e9todos de cuadratura es aproximar esta integral mediante  una suma de evaluaciones de la funci\u00f3n en ciertos puntos del intervalo:</p> \\[\\begin{align} I \\approx \\sum_{i=k}^N w_k \\, f(x_k) \\end{align}\\] <p>donde:</p> <ul> <li>\\(x_k\\) son los puntos de muestreo,</li> <li>\\(w_k\\) son los pesos</li> </ul> <p>Adem\u00e1s, para la cuadratura Gaussiana:</p> <ul> <li>Los puntos de muestreo se escogen de manera tal que no son equidistantes. Esto introduce m\u00e1s grados de libertad para la misma discretizaci\u00f3n en \\(N\\) subregiones.</li> <li>Es exacta para un polinomio de orden \\((2N - 1)\\) o menor.</li> </ul>"},{"location":"explanation/#polinomios-de-legendre","title":"Polinomios de Legendre","text":"<p>Los polinomios de Legendre (\\(P_N(x)\\)) son un sistema de polinomios ortogonales que pueden ser definidos de manera recursiva. Tenemos: \\begin{align} \\forall (M, N) \\in\\mathbb N^2, \\quad \\int_{-1}^1 {\\rm{d}}x P_N(x)P_M(x) = \\frac{2\\delta_{MN}}{2N+1}.  \\end{align}</p> <p>Note que los polinomios est\u00e1n definidos en el intervalo \\([-1, 1]\\).    </p> <p>Los se definen empezando con \\begin{align} P_0(x) = 1 \\Rightarrow P_1(x) = x, \\end{align} tal que los siguientes \u00f3rdenes se generan con la regla de recursividad \\begin{align} (N+1)P_{N+1}(x) = (2N+1)xP_N(x) -NP_{N-1}(x). \\end{align} Alternativamente, los polinomios pueden ser definidos de manera iterativa bajo la regla (f\u00f3rmula de Rodrigues) \\begin{align} P_N(x) = \\frac1{2^N N!}\\frac{d^N}{dx^N}\\left[(x^2-1)^N\\right]. \\end{align}</p>"},{"location":"explanation/#particularidad-de-la-cuadratura-gausslegendre","title":"Particularidad de la cuadratura Gauss\u2013Legendre","text":"<p>En la cuadratura Gauss\u2013Legendre, existe una regla universal para escoger \\(w_k\\) y \\(x_k\\). Los pesos y puntos de muestreo se eligen tal que:</p> <ul> <li>\\(x_k\\) corresponden a las \\(N\\) ra\u00edces (ceros) de los polinomios de Legendre de orden \\(N\\).</li> <li> <p>Los pesos se eligen tal que:</p> <p>\\(\\displaystyle w_k = \\left[\\frac{2}{1-x^2}\\left(\\frac{dP_N}{dx}\\right)^{-2}\\right]_{x={x_k}}\\), con \\(x_k\\) que cumple \\(P_N(x_k)=0\\)</p> </li> </ul> <p>Vea tambi\u00e9n que al estar el m\u00e9todo definido en el intervalo \\([-1, 1]\\) es necesario un cambio de variable a un intervalo arbitrario. En nuestro caso, eso se realizar\u00e1 de manera computacional a patir de una funci\u00f3n establecida, por lo que te\u00f3ricamente no se abordar\u00e1 c\u00f3mo realizarlo. </p> <p>Finalmente, es realevante hablar puntualmente de las ventajas y desventajas del m\u00e9todo:</p> <p>Ventajas:</p> <ul> <li>La ecuaci\u00f3n para evaluar los errores es muy complicada. Sin embargo, la aproximaci\u00f3n mejora con un error que decrece por un factor \\({\\rm{const.}} / N^2\\) cuando se incrementa el n\u00famero de subregiones de discretizaci\u00f3n en uno.</li> <li>Ejemplo: Pasar de \\(N=10\\) a \\(N=11\\), mejora el resultado de la estimaci\u00f3n por un factor de \\(\\approx 100\\). Esto indica que la convergencia ocurre con muy pocos puntos de muestreo.</li> </ul> <p>Desventajas:</p> <ul> <li>S\u00f3lo funciona bien su la funci\u00f3n a integrar es relativamente bien comportada. Si no lo es, se requiren m\u00e1s puntos de muestreo cerca de las regiones problem\u00e1ticas.</li> <li>Es muy complicado evaluar el error de manera precisa si lo necesitamos.</li> </ul>"},{"location":"reference/","title":"Referencia de funciones","text":""},{"location":"reference/#gauss.gaussxw","title":"<code>gaussxw(N)</code>","text":"<p>Genera los puntos de muestreo y pesos de la cuadratura Gauss\u2013Legendre en [-1,1].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gaussxw(4)\n(array([-0.86113631, -0.33998104,  0.33998104,  0.86113631]), array([0.34785485, 0.65214515, 0.65214515, 0.34785485]))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>n\u00famero de puntos de cuadratura.</p> required <p>Returns:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>arreglo de NumPy que contiene los puntos.</p> <code>w</code> <code>ndarray</code> <p>arreglo de Numpy que contiene los pesos.</p> Source code in <code>gauss/gauss.py</code> <pre><code>def gaussxw(N):\n    \"\"\"Genera los puntos de muestreo y pesos de la cuadratura Gauss\u2013Legendre en [-1,1].\n\n    Examples:\n        &gt;&gt;&gt; gaussxw(4)\n        (array([-0.86113631, -0.33998104,  0.33998104,  0.86113631]), array([0.34785485, 0.65214515, 0.65214515, 0.34785485]))\n\n    Args:\n        N (int): n\u00famero de puntos de cuadratura.\n\n    Returns:\n        x (ndarray): arreglo de NumPy que contiene los puntos.\n        w (ndarray): arreglo de Numpy que contiene los pesos.\n\n    \"\"\"\n\n    x, w = np.polynomial.legendre.leggauss(N)\n\n    return x, w\n</code></pre>"},{"location":"reference/#gauss.gaussxwab","title":"<code>gaussxwab(a, b, x, w)</code>","text":"<p>Transforma puntos y pesos de [-1,1] al intervalo [1,3].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; puntos, pesos = gaussxw(4)\n&gt;&gt;&gt; gaussxwab(1, 3, puntos, pesos)\n(array([1.13886369, 1.66001896, 2.33998104, 2.86113631]), array([0.34785485, 0.65214515, 0.65214515, 0.34785485]))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int or float</code> <p>l\u00edmite inferior.</p> required <code>b</code> <code>int or float</code> <p>l\u00edmite superior.</p> required <code>x</code> <code>ndarray</code> <p>puntos en [-1,1].</p> required <code>w</code> <code>ndarray</code> <p>pesos en [-1,1].</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>arreglos transformados al intervalo [1,3].</p> Source code in <code>gauss/gauss.py</code> <pre><code>def gaussxwab(a, b, x, w):\n    \"\"\"Transforma puntos y pesos de [-1,1] al intervalo [1,3].\n\n    Examples:\n        &gt;&gt;&gt; puntos, pesos = gaussxw(4)\n        &gt;&gt;&gt; gaussxwab(1, 3, puntos, pesos)\n        (array([1.13886369, 1.66001896, 2.33998104, 2.86113631]), array([0.34785485, 0.65214515, 0.65214515, 0.34785485]))\n\n    Args:\n        a (int or float): l\u00edmite inferior.\n        b (int or float): l\u00edmite superior.\n        x (ndarray): puntos en [-1,1].\n        w (ndarray): pesos en [-1,1].\n\n    Returns:\n        (tuple): arreglos transformados al intervalo [1,3].\n\n    \"\"\"\n    return 0.5 * (b - a) * x + 0.5 * (b + a), 0.5 * (b - a) * w\n</code></pre>"},{"location":"reference/#gauss.integrando","title":"<code>integrando(varInd)</code>","text":"<p>Funci\u00f3n de prueba: f(x) = x^6 - x^2 sin(2x).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; integrando(1.0)\nnp.float64(0.09070257317431829)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>varInd</code> <code>float or int</code> <p>variable independiente.</p> required <p>Returns:</p> Type Description <code>float</code> <p>valor de la funci\u00f3n evaluada.</p> Source code in <code>gauss/gauss.py</code> <pre><code>def integrando(varInd):\n    \"\"\"Funci\u00f3n de prueba: f(x) = x^6 - x^2 sin(2x).\n\n    Examples:\n        &gt;&gt;&gt; integrando(1.0)\n        np.float64(0.09070257317431829)\n\n    Args:\n        varInd (float or int): variable independiente.\n\n    Returns:\n         (float): valor de la funci\u00f3n evaluada.\n\n    \"\"\"\n    return varInd**6 - varInd**2 * np.sin(2*varInd)\n</code></pre>"},{"location":"tutorials/","title":"Tutorial de uso","text":"<p>En este ejemplo se aplica la cuadratura Gauss\u2013Legendre para aproximar la integral</p> \\[ f(x) = x^6 - x^2 \\sin(2x), \\quad x \\in [1,3] \\]"},{"location":"tutorials/#implementacion-en-python","title":"Implementaci\u00f3n en Python","text":"<pre><code>import numpy as np\nfrom scipy.special import legendre\n\n# Definici\u00f3n de la funci\u00f3n a integrar\ndef integrando(varInd):\n    return varInd**6 - varInd**2 * np.sin(2*varInd)\n\n# Generaci\u00f3n de puntos y pesos en [-1,1]\ndef gaussxw(N):\n    x, w = np.polynomial.legendre.leggauss(N)  \n    return x, w\n\n# Transformaci\u00f3n de intervalo [-1,1] -&gt; [a,b]\ndef gaussxwab(a, b, x, w):\n    return 0.5 * (b - a) * x + 0.5 * (b + a), 0.5 * (b - a) * w\n\n# Intervalo de integraci\u00f3n\na, b = 1, 3\n\n# En este caso, a partir de N=4 se cumple que 2N - 1 &gt; 6, por lo que para 4 o n\u00fameros mayores se obtiene un resultado exacto. \nfor N in [2, 3, 4, 5]:\n    puntos, pesos = gaussxw(N)\n    puntos, pesos = gaussxwab(a, b, puntos, pesos)\n    integral = np.sum(pesos * integrando(puntos))\n    print(\"N = {} \u2192 aproximaci\u00f3n = {}\".format(N, integral))\n</code></pre> <pre><code>N = 2 \u2192 aproximaci\u00f3n = 306.8199344959197\nN = 3 \u2192 aproximaci\u00f3n = 317.264151733829\nN = 4 \u2192 aproximaci\u00f3n = 317.3453903341579\nN = 5 \u2192 aproximaci\u00f3n = 317.34422672196956\n</code></pre>"}]}